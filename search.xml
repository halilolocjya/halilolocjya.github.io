<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[PHP导入大批量数据处理]]></title>
      <url>%2F2017%2F05%2F28%2F2017%2FPHP%E5%AF%BC%E5%85%A5%E5%A4%A7%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[PHP 导入1W条数据 最近做了一个比较大的管理后台的需求。在思考和实现的过程中，感觉又get到一些新技能新思路。特此记录。这次需求，做了一些文件上传读取解析以及写入下载的操作。 具体功能为：导入excel（csv）文件，到nginx服务器解析，调取后台接口，记录错误数据并提供错误文件下载 先说下其中一些瓶颈点： 导入excel/csv文件时，数量要求是1w行/每个文件，如果直接这样去连续串行调1W次接口，会造成nginx请求超时，直接页面跳转 502 bad gateway; 鉴于数据量比较大，用excel导入会导致数据卡慢，所以选用CSV文件来做。具体原因请参考我的另外一篇文章《关于PHP导出CSV文件的实现过程以及一些经常遇到的问题研究》 思路：为了解决内存消耗与服务器响应时间限制的瓶颈，我用了以下方法来实现：【 图1】 【 图2】 分了两步 上传并解析文件，解析的文件存入redis 第一次ajax请求主要是导入数据，算出总数,规定每批调20次接口算出总共需要调多少次接口，存入redis rPush 1.生成一个文件的token 每次要透传 2.返回上传文件的总数 3.返回存入的redis的key 每批读文件需要用到 123456789101112131415161718192021222324252627282930313233343536373839404142434445$token = $this-&gt;save2redis($dealData, $activeId);//生成的redis地址/** * @des 每次上传上来的名单 暂存到redis里 每个文件用一个唯一的key * @param $arr 名单数据 * @param $activeId * @return string 生成的随机数 */ private function save2redis($arr, $activeId) &#123; $redisPrefix = ($this-&gt;REDIS_KEY_PREFIX) . &apos;_&apos; . $activeId . &apos;_&apos;; $ttl = 1 * 24 * 60 * 60;//存一天 if (&quot;development&quot; == ENVIRONMENT) &#123; $ttl = 1 * 1 * 60 * 60; &#125; while (true) &#123; $suffixKey = mt_rand(); $redisKey = $redisPrefix . $suffixKey; if (!$this-&gt;redis-&gt;exists($redisKey)) &#123; $this-&gt;redis-&gt;setTimeout($redisKey, $ttl); foreach ($arr as $key =&gt; $value) &#123; try &#123; #xss过滤 foreach ($value as &amp;$v)&#123; $v= str_replace(&quot;&lt;&quot;,&quot;＜&quot;,$v); $v= str_replace(&quot;&gt;&quot;,&quot;＞&quot;,$v); &#125; if ($key === 0) &#123;//第一行标题 跳过 continue; &#125; $this-&gt;redis-&gt;rPush($redisKey, json_encode($value)); &#125; catch (Exception $e) &#123; &#125; &#125; return $suffixKey; &#125; &#125; &#125; 分批发请求，批量调接口分次返回追加 然后分批发ajax请求，规定每次并发量最大为5，每次发送完对比总共需要调的次数，如果已经发送的次数小于需要调的次数 就继续发ajax请求 123for (var i = 0; i &lt; 5; i++) &#123;//每次并发n个 ajaxRequest(); &#125; 每次ajax请求完成的功能为： 读取redis的前20条数据（lpop） 1234567$readLeft = $this-&gt;redis-&gt;lRange($redisKey, 0, -1);$data = array();for ($i = 0; $i &lt; 20; $i++) &#123; $read = $this-&gt;redis-&gt;lPop($redisKey); $data[] = json_decode($read, true);&#125; 校验 校验成功的放入数组循环调接口 记下返回值，如果失败 与校验失败的一并存入失败数组 然后写入服务器上的csv文件 （文件名为：前缀+第一步导入时的时间戳） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private function write_csv()&#123; $_excelFile = $this-&gt;_excelFilePath; if (!is_dir($_excelFilePath)) &#123; mkdir($_excelFilePath, 0777, true); &#125; // // 不删除之前的文件 直接追加即可 保证头部不会被覆盖 也不会因为ajax请求被乱序 if (file_exists($_excelFile)) &#123; $isFirst=2; // unlink($_excelFile); &#125;else&#123; $isFirst=1; &#125; $maxCount = count($validNotPassArr[0]); if ($isFirst == 1) &#123; $head = array( &apos;序号&apos;, &quot;失败原因&quot;, ); $fp = fopen($_excelFile, &apos;a+&apos;); fwrite($fp, chr(0xEF) . chr(0xBB) . chr(0xBF)); fputcsv($fp, $head); &#125; foreach ($validNotPassArr as $key =&gt; $value) &#123; $clen = count($value); #取最大值 if ($maxCount &lt; $clen) &#123; $maxCount = $clen; &#125; for ($index = 4; $index &lt; $clen; $index++) &#123; if (!empty($value[$index])) &#123; //防止被转成000 $value[$index] = $value[$index] . &quot;\t&quot;; &#125; &#125; $fp = fopen($_excelFile, &apos;a+&apos;); fwrite($fp, chr(0xEF) . chr(0xBB) . chr(0xBF)); fputcsv($fp, $value); &#125; &#125; 每次调用成功 返回 如此 在ajaxRequest成功回调里循环往复，直到完成所有请求. 实现效果为：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP导入文件function]]></title>
      <url>%2F2017%2F05%2F27%2F2017%2Fphp%E5%AF%BC%E5%85%A5%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%2F</url>
      <content type="text"><![CDATA[PHP导入文件相关实践安利上传组件：webuploader 超时时间手动设置：12set_time_limit(60 * 5);ini_set(&apos;memory_limit&apos;, &apos;1024M&apos;); 文件名常用校验1234567if (empty($_FILES[$fileName]) or $_FILES[$fileName][&apos;error&apos;] &gt; 0 or $_FILES[$fileName][&apos;size&apos;] == 0) &#123; $msg = &apos;请选择EXCEL文件&apos;; &#125; elseif ($_FILES[$fileName][&quot;size&quot;] &gt; $fileSizeLimit * 1024 * 1024) &#123;//2M $msg = &apos;文件大于&apos; . $fileSizeLimit . &apos;M，请重新上传&apos;; &#125; elseif (!preg_match(&apos;/\.csv$/&apos;, $_FILES[$fileName][&apos;name&apos;])) &#123; $msg = &apos;文件格式必须是CSV文件，请重新上传&apos;; &#125; 读取上传的文件12345678910111213private function readFile($FILES)&#123; $filename = $FILES[&apos;file&apos;][&apos;tmp_name&apos;]; $fh = fopen($filename, &quot;r&quot;); $contents = fread($fh, filesize($filename)); $contents = $this-&gt;characet2utf8($contents); $lines = explode(PHP_EOL, $contents); fclose($fh); unlink($filename); return $lines;&#125; 读取文件，返回数组，清除格式错误的行123456789101112131415161718192021private function deal_csv($fileData) &#123; $data = array(); foreach ($fileData as $k =&gt; $v) &#123; $exsign = array(&apos;&apos;, chr(9), chr(10), chr(13));//chr(9) tab空格 chr(10) 换行 chr(13) 回车 if (!in_array($v, $exsign)) &#123; $v = explode(&quot;,&quot;, $v); $val = array(); foreach ($v as $key =&gt; $value) &#123; $val[$key] = isset($v[$key]) ? trim($v[$key]) : null; &#125; $data[$k] = $val; &#125; else &#123;//这一行为空 $emptyLine[] = $k + 1; &#125; &#125; return $data; &#125; 文件内容UTF8转码12345678910private function characet2utf8($data)&#123; if (!empty($data)) &#123; $fileType = mb_detect_encoding($data, array(&apos;UTF-8&apos;, &apos;GBK&apos;, &apos;LATIN1&apos;, &apos;BIG5&apos;)); if ($fileType != &apos;UTF-8&apos;) &#123; $data = mb_convert_encoding($data, &apos;utf-8&apos;, $fileType); &#125; &#125; return $data;&#125; 写入csv文件1234567if (!is_dir($_excelFilePath)) &#123; mkdir($_excelFilePath, 0777, true); &#125;file_exists($_excelFile)$fp = fopen($_excelFile, &apos;a+&apos;);fwrite($fp, chr(0xEF) . chr(0xBB) . chr(0xBF));fputcsv($fp, $value); 下载文件1234567891011121314151617181920212223242526272829303132function download_csv() &#123; $_excelFile = $this-&gt;filePath; if (!file_exists($_excelFile)) &#123; echo &apos;&lt;script&gt;alert(&quot;生成文件失败了，请重试&quot;);window.history.back();&lt;/script&gt;&apos;; exit; &#125; $file = fopen($_excelFile, &quot;r&quot;); //返回的文件类型 Header(&quot;Content-type: application/octet-stream&quot;); //按照字节大小返回 Header(&quot;Accept-Ranges: bytes&quot;); //返回文件的大小 Header(&quot;Accept-Length: &quot; . filesize($_excelFile)); //这里对客户端的弹出对话框，对应的文件名 Header(&quot;Content-Disposition: attachment; filename=namelist_$activeid&quot;.&quot;_&quot;.$timestamp.&quot;.csv&quot;); //一次只传输1024个字节的数据给客户端 //向客户端回送数据 $buffer = 1024; // //判断文件是否读完 while (!feof($file)) &#123; //将文件读入内存 $file_data = fread($file, $buffer); //每次向客户端回送1024个字节的数据 echo $file_data; &#125; fclose($file);// unlink($_excelFile); //删除文件 &#125; ### 上传图片处理12345678910111213141516171819202122232425262728293031323334353637public function upload_file()&#123;$typeArr = array(&apos;image/gif&apos; =&gt; &apos;gif&apos;, &apos;image/jpeg&apos; =&gt; &apos;jpeg&apos;, &apos;image/jpg&apos; =&gt; &apos;jpg&apos;, &apos;image/png&apos; =&gt; &apos;png&apos;, &apos;image/pjpeg&apos; =&gt; &apos;pjpeg&apos;); if (!in_array($_FILES[&apos;file&apos;][&apos;type&apos;], array_keys($typeArr)) &amp;&amp; ((int)$_FILES[&apos;file&apos;][&apos;size&apos;] &lt; 5000000)) &#123; $data = array( &apos;errcode&apos; =&gt; 100, &apos;errmsg&apos; =&gt; &apos;文件类型不正确 或 文件超过大小限制&apos;, ); header(&apos;Content-type: application/json; charset=utf-8&apos;); die(json_encode($data)); &#125; $datePath = date(&apos;Ym&apos;); if ($_FILES[&apos;file&apos;][&apos;error&apos;] &gt; 0) &#123; echo &quot;failed&quot;; &#125; else &#123; //postCurl $return = json_decode($return, true); if ($return[&apos;code&apos;] == 0) &#123; $data = array( &apos;errcode&apos; =&gt; 0, &apos;errmsg&apos; =&gt; &apos;&apos;, &apos;data&apos; =&gt; array(&apos;filePath&apos; =&gt; &apos; &apos; . $pathBase), ); &#125; else &#123; $data = array( &apos;errcode&apos; =&gt; 103, &apos;errmsg&apos; =&gt; &apos;上传失败&apos;, ); &#125; header(&apos;Content-type: application/json; charset=utf-8&apos;); die(json_encode($data)); &#125; &#125; &#125; PHP操作redis相关function连接redis：12$this-&gt;load-&gt;driver(&apos;cache&apos;);$this-&gt;redis = $this-&gt;cache-&gt;redis-&gt;getRedis(); 检测redisKey是否存在1$this-&gt;redis-&gt;exists($redisKey) 设置redis生存时间12$ttl = 1 * 24 * 60 * 60;//存一天$this-&gt;redis-&gt;setTimeout($redisKey, $ttl); 存入数据的一个item1$this-&gt;redis-&gt;rPush($redisKey, json_encode($value)); 生成随机数1$suffixKey = mt_rand(); ### 取出剩下的所有元素1$readLeft = $this-&gt;redis-&gt;lRange($redisKey, 0, -1); 按顺序取出数组的一个元素12$read = $this-&gt;redis-&gt;lPop($redisKey);$data[] = json_decode($read, true); 更多请参考： http://www.redis.cn/commands/blpop.html http://www.cnblogs.com/stephen-liu74/archive/2012/03/26/2356951.html http://www.cnblogs.com/weafer/archive/2011/09/21/2184059.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图解http随手记]]></title>
      <url>%2F2017%2F05%2F20%2F2017%2F%E5%9B%BE%E8%A7%A3http%2F</url>
      <content type="text"><![CDATA[HTTP状态码状态码类别： Tables 类别 原因短语 1XX informational 接收的请求正在处理 2XX success（成功状态码） 请求正常处理完毕 3XX Redirectional(重定向状态码) 需要进行附加操作以完成请求 4XX client Error(客户端请求错误) 服务器无法处理请求 5XX server Error(服务器错误状态码) 服务器无法处理请求]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[charle]]></title>
      <url>%2F2017%2F04%2F23%2F2017%2Fcharles%2F</url>
      <content type="text"><![CDATA[about作为一个合格的前端er，抓包分析请求http/https请求是必不可少的。 如果在windows客户端下，fiddler+willow组合所向披靡；如果是mac OS呢，这里 咱们不得不提到Charles+GasMask 按照教程安装破解版charleshttp://www.sdifenzhou.com/charles4.html 设置 安装完成后，打开charles,设置（https请求） 安装证书 SSL Proxy Settings 打开mac os proxy 然后就可以开心抓https本机请求啦 坑 gasmask在设置后就会生效，即使退出gas Mask，mac的host也会保持退出前的状态，所以如果不在企业内网，千万记得把gasmask环境切回到原始host. 在外网发现打不开公司首页了，可以检查下host是否正确。 mac下查host方法： 1.1 先打开 Mac 系统中的 Finder 1.2 Shift+Command+G,输入 Hosts 文件的所在路径：/etc/hosts 1.3 双击打开]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计》Records]]></title>
      <url>%2F2017%2F04%2F16%2FJs%E5%90%AF%E7%A4%BA%E5%BD%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-md%2F</url>
      <content type="text"><![CDATA[写在前面，一些与主题无关的闲话：最近工作里有一些代码需要整理交接，然后再 Tower 上团队协作写了一些md指引文档，但是到结果验收阶段，需要给组内所有同学公开，放在我司自己的开发环境的服务器上，因此选择了 docsify 来进行编译，还是挺好用的。可以试下~ Records背景：最近比较咸，重新看了一遍JavaScript高级程序设计，自己随手记得一点点笔记也没啥地方可以放 就先放这里吧 console.log 与console.dir console.dir显示一个对象的所有属性和方法console.log显示这个对象 typeof 与 instanceof typeof会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,undefined,function；例： alert(typeof(1));//numberalert(typeof(“abc”));//stringalert(typeof(true));//booleanalert(typeof(m));//undefined instanceof返回的是一个布尔值,instanceof只能用来判断对象和函数，不能用来判断字符串和数字等， 123456789101112[] instanceof Objecttruetypeof []&quot;object&quot;&#123;&#125; instanceof Objecttruevar arr = [1,2,3,1];console.log(arr.constructor === Array);true 判断是不是数组 1234Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray(&apos;foobar&apos;); // falseArray.isArray(undefined); // false 正则表达式 var pattern1=/[bc]at/i; var pattern2=/[bc]at/i; var pattern3=/.at/i; var pattern2=new RegExp(“[bc]at”,”i”); arguments callee caller arguments 是一个类数组对象，包含传入函数中的所有参数 callee属性是一个指针，指向拥有这个arguments对象的函数。 caller 这个属性保存着调用当前函数的函数的引用 123456789101112131415161718192021222324252627282930//&quot;use strict&quot;; 加上就报错//阶乘function factorial(num)&#123;if(num&lt;1)&#123;return 1;&#125;else&#123;console.log(num);return num*arguments.callee(num-1);&#125;&#125;console.log(factorial(5));var newFac=factorial;factorial=function()&#123;return 0;&#125;console.log(newFac(5));console.log(factorial(5));//callerfunction outer()&#123;inner()&#125;function outer2()&#123;inner();&#125;function inner()&#123;alert(arguments.callee.caller);&#125; 运行结果： 12345678910111213145432112005VM1311:52 Uncaught TypeError: &apos;caller&apos;, &apos;callee&apos;, and &apos;arguments&apos; properties may not be accessed on strict mode functions or the arguments objects for calls to themat factorial (VM1311:52)at window.onload (VM1311:55)factorial @ VM1311:52window.onload @ VM1311:55 严格模式下,以下会导致错误： arguments.callee arguments.caller 为函数的caller赋值 函数属性和方法 每个函数包含两个属性 length（函数希望接收的命名参数的个数）和prototype（对于引用类型而言，prototype保存了它们所有的实例方法所在 在ES5中，不可枚举，不能用for-in发现） 每个函数包含两个非继承而来的方法：apply和call， 在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。apply方法接收两个参数 在其中运行的作用域 参数数组 call 区别仅在于接受参数的方式不同 传参应用 123456789101112131415function sum(num1,num2)&#123;return(num1+num2);&#125;function call1(num1,num2,num3)&#123;return sum.apply(this,arguments);&#125;console.log(call1(1,2,3));function call_or(num1,num2)&#123;return sum.call(this,num1,num2);&#125;call_or(1,3) 扩充函数赖以运行的作用域： 12345678910window.color=&quot;red&quot;;var o=&#123;color:&apos;blue&apos;&#125;;function c()&#123;alert(this.color);&#125;c.call(this); //redc.call(window);//red 在全局对象中调用函数c.call(o);//blue 在对象o作用域中调用函数 好处：对象与方法不需要有任何耦合关系；另一个相似功能的方法是bind 12var obj=c.bind(o);obj(); P136 P119 5.6 基本包装类型 数据类型 Number类型 1234567var numberObject = new Number(10);var numberValue = 10;alert(typeof numberObject); //&quot;object&quot;alert(typeof numberValue); //&quot;number&quot;alert(numberObject instanceof Number); //truealert(numberValue instanceof Number); //false 在使用typeof操作符测试基本类型数值时，始终会返回”number”，而在测试Number对象时，则会返回”object”。类似地，Number对象是Number类型的实例，而基本类型的数值则不是。 String类型 charAt charCodeAt concat slice substring substr indexOf lastIndexOf trim toUpperCase toLowerCase Math对象ceil floor round random abs exp log 123var arr=[1,2,3,4,5,90,889];var max=Math.max.apply(Math,arr);var max=Math.max.call(Math,1,2,3,4,5,90,889) 这个技巧的关键是把math对象设置成apply的第一个参数 从而正确地设置this的值 属性类型defineProperty defineProperties Object.getOwnPropertyDescriptor 数据属性 包含一个数据值的位置 可以读取和写入值 枚举 删除等 包括 Configuration【能否通过delete删除属性从而重新定义属性】 Enumerable 对象是否可以枚举 for-in Writable 是否可写 Value 属性值四个属性 要修改属性默认的特性 必须要用ES5 Object.defineProperty() 方法。传参三个：属性所在对象 属性名 描述符对象 123456789var person = &#123;&#125;;Object.defineProperty(person, &quot;name&quot;, &#123;writable: false,value: &quot;Nicholas&quot;&#125;);alert(person.name); //&quot;Nicholas&quot;person.name = &quot;Greg&quot;;alert(person.name); //&quot;Nicholas&quot;DataPropertiesExample01.htm 创建对象 构造函数 ：与普通函数的区别 就是需要使用new操作符来调用 对象字面量 工厂模式 要创建Person实例，必须使用new操作符。经历4个步骤： 创建一个新对象 将构造函数的作用域赋给新对象 （this指向这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 constructor属性标识对象类型 但是用instanceof属性来检测更可靠、 构造函数模式：12 原型模式：原型链：利用原型让一个引用类型继承另一个引用类型的属性和方法。粗体斜体 窗口位置window.screenTop window.screenLeft window.screenX window.screenYinnerWidth outerWidth innerHeight outerHeight 获得页面可视窗口的宽度document.documentElement.clientWidthdocument.body.clientWidth 1234567891011var pageWidth = window.innerWidth,pageHeight = window.innerHeight;if (typeof pageWidth != &quot;number&quot;)&#123;if (document.compatMode == &quot;CSS1Compat&quot;)&#123;//标准模式pageWidth = document.documentElement.clientWidth;pageHeight = document.documentElement.clientHeight;&#125; else &#123;//混杂模式pageWidth = document.body.clientWidth;pageHeight = document.body.clientHeight;&#125;&#125; 检测浏览器新开窗口是否被阻止：123456789101112var blocked = false;try &#123;var wroxWin = window.open(&quot;http://www.baidu.com&quot;, &quot;_blank&quot;);if (wroxWin == null)&#123;blocked = true;&#125;&#125; catch (ex)&#123;blocked = true;&#125;if (blocked)&#123;alert(&quot;The popup was blocked!&quot;);&#125; setTimeout:123456//设置超时调用var timeoutId = setTimeout(function() &#123;alert(&quot;Hello world!&quot;);&#125;, 1000);//注意：把它取消clearTimeout(timeoutId); JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个参数告诉JavaScript再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。 超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined。 一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，最好不要使用间歇调用。 1234567891011121314// 在这个例子中，变量num每半秒钟递增一次，当递增到最大值时就会取消先前设定的间歇调用。这//个模式也可以使用超时调用来实现。var num = 0;var max = 10;function incrementNumber() &#123;num++;//如果执行次数未达到max设定的值，则设置另一次超时调用if (num &lt; max) &#123;setTimeout(incrementNumber, 500);&#125; else &#123;alert(&quot;Done&quot;);&#125;&#125;setTimeout(incrementNumber, 500); viewpointlocation: hash host hostname href parthname port protocal search这些值随便改变一个都会在浏览器历史记录里重新生成一条记录 可以通过后退或者前进访问到要防止这种行为，可以通过1234567891011121314151617181920212223242526272829## BOM 浏览器对象模型 以Windows对象为依托，表示浏览器窗口以及页面的可见区域&gt;浏览器对象模型（BOM）以window对象为依托，表示浏览器窗口以及页面可见区域。同时，window对象还是ECMAScript中的Global对象，因而所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下。本章讨论了下列BOM的组成部分。 在使用框架时，每个框架都有自己的window对象以及所有原生构造函数及其他函数的副本。每个框架都保存在frames集合中，可以通过位置或通过名称来访问。 有一些窗口指针，可以用来引用其他框架，包括父框架。 top对象始终指向最外围的框架，也就是整个浏览器窗口。 parent对象表示包含当前框架的框架，而self对象则回指window。 使用location对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性地修改浏览器的URL。 调用replace()方法可以导航到一个新URL，同时该URL会替换浏览器历史记录中当前显示的页面。 navigator对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏览器；不过，也有一些公共的属性（如userAgent）存在于所有浏览器中。BOM中还有两个对象：screen和history，但它们的功能有限。screen对象中保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。history 对象为访问浏览器的历史记录开了一个小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。## DOMgetElementByIdgetElementByTagNamegetAttribute setAttribute removeAttributequerySelectorquerySelectorAll var $div=document.getElementById(‘mydiv’);console.log($div.getAttribute(‘data-id’)); 1234## 动态引入JS或者CSS** 引入脚本 *** 引入外部文件 function loadScript(url){var script = document.createElement(“script”);script.type = “text/javascript”;script.src = url;document.body.appendChild(script);}//然后，就可以通过调用这个函数来加载外部的JavaScript文件了：loadScript(“client.js”);12* 行内方式 function loadScriptString(code){var script = document.createElement(“script”);script.type = “text/javascript”;try {script.appendChild(document.createTextNode(code));} catch (ex){script.text = code;}document.body.appendChild(script);}//下面是调用这个函数的示例：loadScriptString(“function sayHi(){alert(‘hi’);}”);123** 引入CSS *** 引入外部文件 function loadStyles(url){var link = document.createElement(“link”);link.rel = “stylesheet”;link.type = “text/css”;link.href = url;var head = document.getElementsByTagName(“head”)[0];head.appendChild(link);}//调用loadStyles()函数的代码如下所示：loadStyles(“styles.css”);12* 行内方式 function loadStyleString(css){var style = document.createElement(“style”);style.type = “text/css”;try{style.appendChild(document.createTextNode(css));} catch (ex){style.styleSheet.cssText = css;}var head = document.getElementsByTagName(“head”)[0];head.appendChild(style);} //调用这个函数的示例如下：loadStyleString(“body{background-color:red}”);12345678910111213## HTMLDocument的变化&gt; * document.readyState loading/complete&gt; * 兼容模式 document.compatMode CSS1Compat(标准模式) BackCompat(混杂模式)&gt;var head = document.head || document.getElementsByTagName(&quot;head&quot;)[0];&gt;$(&apos;#p5&apos;)[0].scrollIntoView()&gt;clientWidth=元素内容宽度+内边距宽度 clientHeight=元素内容高度+内边距高度 function getViewport(){if (document.compatMode == “BackCompat”){return {width: document.body.clientWidth,height: document.body.clientHeight};} else {return {width: document.documentElement.clientWidth,height: document.documentElement.clientHeight};}}12 var docHeight = Math.max(document.documentElement.scrollHeight,document.documentElement.clientHeight);var docWidth = Math.max(document.documentElement.scrollWidth,document.documentElement.clientWidth);``` scrollLeft scrollTop scrollHeight scrollWidth getBoundingClientRect()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[微信硬件JS-Api开发不完全指南]]></title>
      <url>%2F2017%2F02%2F06%2F%E5%BE%AE%E4%BF%A1%E7%A1%AC%E4%BB%B6JS-Api%E5%BC%80%E5%8F%91%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[1.引入JS库 1&lt;script type=&apos;text/javascript&apos; src=&apos;//res.wx.qq.com/open/js/jweixin-1.0.0.js&apos;&gt;&lt;/script&gt; 2.为页面注入配置信息123456789wx.config(&#123; beta: true, // 开启内测接口调用，注入wx.invoke方法,非常重要!!必须有这个 debug: true,//开启调试接口，alert运行结果 appId: &apos;&apos;,//必填，公众号的唯一标识, timestamp: &apos;&apos;,//必填，生成签名的时间戳 nonceStr: &apos;&apos;,//必填，生成签名的随机串 signature: &apos;&apos;,//必填，签名 jsApiList: []//要调用的js函数，必须把函数名字写入数组&#125;); 这里我的jsApiList为12345678910111213141516jsApiList: [ &apos;openWXDeviceLib&apos;,//初始化设备库（只支持蓝牙设备） &apos;closeWXDeviceLib&apos;,//关闭设备库（只支持蓝牙设备） &apos;getWXDeviceInfos&apos;,//获取设备信息（获取当前用户已绑定的蓝牙设备列表） &apos;sendDataToWXDevice&apos;,//发送数据给设备 &apos;startScanWXDevice&apos;,//扫描设备（获取周围所有的设备列表，无论绑定还是未被绑定的设备都会扫描到） &apos;stopScanWXDevice&apos;,//停止扫描设备 &apos;connectWXDevice&apos;,//连接设备 &apos;disconnectWXDevice&apos;,//断开设备连接 &apos;getWXDeviceTicket&apos;,//获取操作凭证 &apos;onWXDeviceBindStateChange&apos;,//微信客户端设备绑定状态被改变时触发此事件 &apos;onWXDeviceStateChange&apos;,//监听连接状态，可以监听连接中、连接上、连接断开 &apos;onReceiveDataFromWXDevice&apos;,//接收到来自设备的数据时触发 &apos;onScanWXDeviceResult&apos;,//扫描到某个设备时触发 &apos;onWXDeviceBluetoothStateChange&apos;,//手机蓝牙打开或关闭时触发 ] 如果想要测一下微信版本是不是支持这几个api，可以这样写：1234567 wx.checkJsApi(&#123; jsApiList: [&apos;openWXDeviceLib&apos;, &apos;onScanWXDevicesResult&apos;, &apos;getWXDeviceInfos&apos;], // 需要检测的JS接口列表，所有JS接口列表见附录2, success: function (res) &#123; console.log(res); &#125;&#125;); 3.初始化设备库函数 通过ready接口处理成功验证123456wx.ready(function () &#123; wx.invoke(&apos;openWXDeviceLib&apos;, &#123;connType: &apos;blue&apos;&#125;, function (res) &#123; console.debug(&apos;openWXDeviceLib重新打开设备库==&gt;&apos;); console.log(res); &#125;);&#125;) 坑：重新扫描设备根本什么都扫不出来，即使是刷新页面也不顶用 解决方法：每次扫描前，先调用closeWXDeviceLib关闭设备库，再调用openWXDeviceLib打开设备库。这样就相当于重新初始化了一遍设备库，你现在再重新扫描，就可以扫描到设备了。 代码：1234567891011121314wx.invoke(&quot;stopScanWXDevice&quot;, &#123;&#125;, function (res) &#123; console.debug(&apos;stopScanWXDevice&apos;); console.log(res); &#125;);wx.invoke(&quot;closeWXDeviceLib&quot;, &#123;&#125;, function (res) &#123; console.debug(&apos;closeWXDeviceLib关闭设备库==&gt;&apos;); console.log(res);&#125;);wx.invoke(&apos;openWXDeviceLib&apos;, &#123;connType: &apos;blue&apos;&#125;, function (res) &#123; console.debug(&apos;openWXDeviceLib重新打开设备库==&gt;&apos;); console.log(res);&#125;); 4.监听设备返回的信息1234wx.on(&apos;onReceiveDataFromWXDevice&apos;, function (res) &#123; console.warn(&apos;onReceiveDataFromWXDevice=&gt;&apos;); console.log(JSON.stringify(res));&#125;); 5.发送消息到设备 收发数据前需进行 base64 的编解码。这里，我用到一个库：1&lt;script type=&apos;text/javascript&apos; src=&apos;base64.js&apos;&gt;&lt;/script&gt; 出处：https://github.com/dankogai/js-base64/blob/master/base64.js 12345678910var data=&#123;&quot;deviceId&quot;:deviceId,&quot;base64Data&quot;: Base64.encode(&apos;你要发送的数据&apos;)&#125;;console.log(data);wx.invoke(&apos;sendDataToWXDevice&apos;,data , function(res)&#123; //回调 console.info(&apos;发消息到设备sendMsg&apos;); console.log(data); console.log(res); $(&apos;#dataFromDevice&apos;).append(&apos;发送消息的结果：&apos;+JSON.stringify(res)); alert(&apos;已发送 请查看控制板&apos;);&#125;); 说明： 1.需要在微信对应设备号内才能使用对应的api。 2.必须要在设备号设置的安全域名下才能正常使用api 3.本篇内所有的console.log 等输出到控制台 都是用的vconsole调试工具实现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于PHP导出CSV文件的实现过程以及一些经常遇到的问题研究]]></title>
      <url>%2F2016%2F12%2F10%2F%E5%85%B3%E4%BA%8EPHP%E5%AF%BC%E5%87%BACSV%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E7%A0%94%E7%A9%B6%2F</url>
      <content type="text"><![CDATA[写在前面：预告：前两天做了很多关于导入导出CSV、照片的蛋疼的需求，准备上一篇大文章~正在总结中……如果有空，下周六应该可以出~ 导出功能在管理后台算是比较常见的了。在实现导出表格类信息的功能时，可以选择两种实现方式： 导出为excel 导出为csv文件格式 用csv方式导出，则可以像导出txt一样，以文本流的方式进行流式处理，不但能导出海量信息，而且流式处理占用内存极低，服务器对浏览器的响应也是非常迅速的。理论上是不限量的。具体能导出多少条，是由服务器的响应时间、PHP的运行时间和内存等限制决定。但是如果用excel来打开csv，超过65536行的数据都会看不见，这是excel程序的问题。本次导出数据量很大。所以选择csv。总体实现思路为：先把需要导出的数据存到数组里，然后写入到文件。话不多说，还是直接上代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function export()&#123; $data=array( array( &apos;nId&apos; =&gt; &apos;90&apos;, &apos;nick&apos; =&gt; &apos;piapia&apos;, ), array( &apos;nId&apos; =&gt; &apos;91&apos;, &apos;nick&apos; =&gt; &apos;monkey&apos;, ) ); $head = array( &apos;nId&apos; =&gt; &apos;id&apos;, &apos;nick&apos; =&gt; &apos;昵称&apos;, ); $name = &quot;filetoexport&quot; . date(&apos;YmdHis&apos;, time()); $this-&gt;writeCsvToBrowser($name, $head, $data);&#125;function writeCsvToBrowser($filename,$headLine,$data,$lostData=array()) &#123; $out = implode(&apos;,&apos;, $headLine); $out = iconv(&apos;UTF-8&apos;, &apos;GBK//IGNORE&apos;,$out); foreach ($data as $v) &#123; $line = array(); foreach (array_keys($headLine) as $objAttr) &#123; if (is_object($v) &amp;&amp; isset($v-&gt;$objAttr)) &#123; $cellValue = $v-&gt;$objAttr; &#125;elseif(is_array($v) &amp;&amp; isset($v[$objAttr])) &#123; $cellValue = $v[$objAttr]; &#125;else &#123; $cellValue = $lostData[$objAttr]; &#125; $line[] = $cellValue; &#125; $line = array_map(&apos;csvFormate&apos;,$line); $out .= &quot;\n&quot;; $lineStr= implode(&apos;,&apos;, $line); //iconv转换编码对字符串有长度限制，如果太长就会被截断。 $lineStr= @iconv(&apos;UTF-8&apos;, &apos;GBK//IGNORE&apos;, $lineStr); $out .= $lineStr; &#125; header(&quot;Cache-Control: must-revalidate, post-check=0, pre-check=0&quot;); header(&quot;Content-Length: &quot; . strlen($out)); header(&quot;Content-type: text/x-csv&quot;); header(&quot;Content-Disposition:filename=$filename.csv&quot;); echo $out;&#125;function csvFormate($str) &#123; if (&apos;&apos;===$str) &#123; return &apos;&apos;; &#125; $find = FALSE; foreach (array(&apos;,&apos;,&apos;&quot;&apos;,&quot;\n&quot;,&quot;\t&quot;) as $v)&#123; if (FALSE===strpos($str, $v)) &#123; $find = true; break; &#125; &#125; if (!$find) &#123; return $str; &#125; $str = str_replace(&apos;&quot;&apos;, &apos;&quot;&quot;&apos;, $str); return sprintf(&apos;&quot;%s&quot;&apos;,$str);&#125; 在实现这个功能时，有一些问题需要大家注意一下。1.精度丢失问题：问题描述：导出后，发现有一个字段总是跟取得不一样，Id为1918553121332457在导出后变成1918553121332450，也就是说最后一位 总是变成了0。原因：Excel数值显示精度为15位造成精度丢失。解决思路：强制转化成字符串1$strId.&quot;\t&quot; 或者1$strId.&quot;\n&quot; 需要注意的是，这样加是没有用的：1$strId.&quot; &quot; 2.PHP运行时间的限制，导致程序被强制中断。在不能随便改变php.ini文件里PHP运行的时间限制下，可以这样设置来增加运行时间：1set_time_limit(60*5); 3.默认内存设置太小，导致文件写入失败：可以尝试这样解决1ini_set(&apos;memory_limit&apos;,&apos;1024M&apos;); 4.奇淫技巧如果不想文件在读取或者写入的时候，因为用户的误操作被中断。可以通过如下参数实现：1ignore_user_abort(true);]]></content>
    </entry>

    
  
  
</search>
