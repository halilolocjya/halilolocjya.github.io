{"meta":{"title":"piapia's secret","subtitle":null,"description":null,"author":"utopia","url":"https://github.com/halilolocjya/halilolocjya.github.io.git"},"pages":[{"title":"tags","date":"2017-04-16T08:09:53.000Z","updated":"2017-04-16T08:09:53.000Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"charles使用手册","slug":"charles使用手册","date":"2017-04-23T09:11:59.000Z","updated":"2017-04-23T10:55:32.000Z","comments":true,"path":"2017/04/23/charles使用手册/","link":"","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/2017/04/23/charles使用手册/","excerpt":"about作为一个合格的前端er，抓包分析请求http/https请求是必不可少的。 如果在windows客户端下，fiddler+willow组合所向披靡；如果是mac OS呢，这里 咱们不得不提到Charles+GasMask","text":"about作为一个合格的前端er，抓包分析请求http/https请求是必不可少的。 如果在windows客户端下，fiddler+willow组合所向披靡；如果是mac OS呢，这里 咱们不得不提到Charles+GasMask 按照教程安装破解版charleshttp://www.sdifenzhou.com/charles4.html 设置 安装完成后，打开charles,设置（https请求） 安装证书 SSL Proxy Settings 打开mac os proxy 然后就可以开心抓https本机请求啦 坑 gasmask在设置后就会生效，即使退出gas Mask，mac的host也会保持退出前的状态，所以如果不在企业内网，千万记得把gasmask环境切回到原始host. 在外网发现打不开公司首页了，可以检查下host是否正确。 mac下查host方法： 1.1 先打开 Mac 系统中的 Finder 1.2 Shift+Command+G,输入 Hosts 文件的所在路径：/etc/hosts 1.3 双击打开","categories":[],"tags":[{"name":"抓包工具","slug":"抓包工具","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/抓包工具/"},{"name":"gas mask","slug":"gas-mask","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/gas-mask/"},{"name":"charles","slug":"charles","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/charles/"}]},{"title":"charle","slug":"2017/charles","date":"2017-04-23T09:11:59.000Z","updated":"2017-04-23T10:32:00.000Z","comments":true,"path":"2017/04/23/2017/charles/","link":"","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/2017/04/23/2017/charles/","excerpt":"about作为一个合格的前端er，抓包分析请求http/https请求是必不可少的。 如果在windows客户端下，fiddler+willow组合所向披靡；如果是mac OS呢，这里 咱们不得不提到Charles+GasMask","text":"about作为一个合格的前端er，抓包分析请求http/https请求是必不可少的。 如果在windows客户端下，fiddler+willow组合所向披靡；如果是mac OS呢，这里 咱们不得不提到Charles+GasMask 按照教程安装破解版charleshttp://www.sdifenzhou.com/charles4.html 设置 安装完成后，打开charles,设置（https请求） 安装证书 SSL Proxy Settings 打开mac os proxy 然后就可以开心抓https本机请求啦 坑 gasmask在设置后就会生效，即使退出gas Mask，mac的host也会保持退出前的状态，所以如果不在企业内网，千万记得把gasmask环境切回到原始host. 在外网发现打不开公司首页了，可以检查下host是否正确。 mac下查host方法： 1.1 先打开 Mac 系统中的 Finder 1.2 Shift+Command+G,输入 Hosts 文件的所在路径：/etc/hosts 1.3 双击打开","categories":[],"tags":[{"name":"抓包工具","slug":"抓包工具","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/抓包工具/"},{"name":"gas mask","slug":"gas-mask","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/gas-mask/"},{"name":"charles","slug":"charles","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/charles/"}]},{"title":"《JavaScript高级程序设计》Records","slug":"Js启示录学习记录-md","date":"2017-04-15T18:11:59.000Z","updated":"2017-04-16T16:19:16.000Z","comments":true,"path":"2017/04/16/Js启示录学习记录-md/","link":"","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/2017/04/16/Js启示录学习记录-md/","excerpt":"写在前面，一些与主题无关的闲话：最近工作里有一些代码需要整理交接，然后再 Tower 上团队协作写了一些md指引文档，但是到结果验收阶段，需要给组内所有同学公开，放在我司自己的开发环境的服务器上，因此选择了 docsify 来进行编译，还是挺好用的。可以试下~ Records背景：最近比较咸，重新看了一遍JavaScript高级程序设计，自己随手记得一点点笔记也没啥地方可以放 就先放这里吧","text":"写在前面，一些与主题无关的闲话：最近工作里有一些代码需要整理交接，然后再 Tower 上团队协作写了一些md指引文档，但是到结果验收阶段，需要给组内所有同学公开，放在我司自己的开发环境的服务器上，因此选择了 docsify 来进行编译，还是挺好用的。可以试下~ Records背景：最近比较咸，重新看了一遍JavaScript高级程序设计，自己随手记得一点点笔记也没啥地方可以放 就先放这里吧 console.log 与console.dir console.dir显示一个对象的所有属性和方法console.log显示这个对象 typeof 与 instanceof typeof会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,undefined,function；例： alert(typeof(1));//numberalert(typeof(“abc”));//stringalert(typeof(true));//booleanalert(typeof(m));//undefined instanceof返回的是一个布尔值,instanceof只能用来判断对象和函数，不能用来判断字符串和数字等， 123456789101112[] instanceof Objecttruetypeof []&quot;object&quot;&#123;&#125; instanceof Objecttruevar arr = [1,2,3,1];console.log(arr.constructor === Array);true 判断是不是数组 1234Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray(&apos;foobar&apos;); // falseArray.isArray(undefined); // false 正则表达式 var pattern1=/[bc]at/i; var pattern2=/[bc]at/i; var pattern3=/.at/i; var pattern2=new RegExp(“[bc]at”,”i”); arguments callee caller arguments 是一个类数组对象，包含传入函数中的所有参数 callee属性是一个指针，指向拥有这个arguments对象的函数。 caller 这个属性保存着调用当前函数的函数的引用 123456789101112131415161718192021222324252627282930//&quot;use strict&quot;; 加上就报错//阶乘function factorial(num)&#123;if(num&lt;1)&#123;return 1;&#125;else&#123;console.log(num);return num*arguments.callee(num-1);&#125;&#125;console.log(factorial(5));var newFac=factorial;factorial=function()&#123;return 0;&#125;console.log(newFac(5));console.log(factorial(5));//callerfunction outer()&#123;inner()&#125;function outer2()&#123;inner();&#125;function inner()&#123;alert(arguments.callee.caller);&#125; 运行结果： 12345678910111213145432112005VM1311:52 Uncaught TypeError: &apos;caller&apos;, &apos;callee&apos;, and &apos;arguments&apos; properties may not be accessed on strict mode functions or the arguments objects for calls to themat factorial (VM1311:52)at window.onload (VM1311:55)factorial @ VM1311:52window.onload @ VM1311:55 严格模式下,以下会导致错误： arguments.callee arguments.caller 为函数的caller赋值 函数属性和方法 每个函数包含两个属性 length（函数希望接收的命名参数的个数）和prototype（对于引用类型而言，prototype保存了它们所有的实例方法所在 在ES5中，不可枚举，不能用for-in发现） 每个函数包含两个非继承而来的方法：apply和call， 在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。apply方法接收两个参数 在其中运行的作用域 参数数组 call 区别仅在于接受参数的方式不同 传参应用 123456789101112131415function sum(num1,num2)&#123;return(num1+num2);&#125;function call1(num1,num2,num3)&#123;return sum.apply(this,arguments);&#125;console.log(call1(1,2,3));function call_or(num1,num2)&#123;return sum.call(this,num1,num2);&#125;call_or(1,3) 扩充函数赖以运行的作用域： 12345678910window.color=&quot;red&quot;;var o=&#123;color:&apos;blue&apos;&#125;;function c()&#123;alert(this.color);&#125;c.call(this); //redc.call(window);//red 在全局对象中调用函数c.call(o);//blue 在对象o作用域中调用函数 好处：对象与方法不需要有任何耦合关系；另一个相似功能的方法是bind 12var obj=c.bind(o);obj(); P136 P119 5.6 基本包装类型 数据类型 Number类型 1234567var numberObject = new Number(10);var numberValue = 10;alert(typeof numberObject); //&quot;object&quot;alert(typeof numberValue); //&quot;number&quot;alert(numberObject instanceof Number); //truealert(numberValue instanceof Number); //false 在使用typeof操作符测试基本类型数值时，始终会返回”number”，而在测试Number对象时，则会返回”object”。类似地，Number对象是Number类型的实例，而基本类型的数值则不是。 String类型 charAt charCodeAt concat slice substring substr indexOf lastIndexOf trim toUpperCase toLowerCase Math对象ceil floor round random abs exp log 123var arr=[1,2,3,4,5,90,889];var max=Math.max.apply(Math,arr);var max=Math.max.call(Math,1,2,3,4,5,90,889) 这个技巧的关键是把math对象设置成apply的第一个参数 从而正确地设置this的值 属性类型defineProperty defineProperties Object.getOwnPropertyDescriptor 数据属性 包含一个数据值的位置 可以读取和写入值 枚举 删除等 包括 Configuration【能否通过delete删除属性从而重新定义属性】 Enumerable 对象是否可以枚举 for-in Writable 是否可写 Value 属性值四个属性 要修改属性默认的特性 必须要用ES5 Object.defineProperty() 方法。传参三个：属性所在对象 属性名 描述符对象 123456789var person = &#123;&#125;;Object.defineProperty(person, &quot;name&quot;, &#123;writable: false,value: &quot;Nicholas&quot;&#125;);alert(person.name); //&quot;Nicholas&quot;person.name = &quot;Greg&quot;;alert(person.name); //&quot;Nicholas&quot;DataPropertiesExample01.htm 创建对象 构造函数 ：与普通函数的区别 就是需要使用new操作符来调用 对象字面量 工厂模式 要创建Person实例，必须使用new操作符。经历4个步骤： 创建一个新对象 将构造函数的作用域赋给新对象 （this指向这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 constructor属性标识对象类型 但是用instanceof属性来检测更可靠、 构造函数模式：12 原型模式：原型链：利用原型让一个引用类型继承另一个引用类型的属性和方法。粗体斜体 窗口位置window.screenTop window.screenLeft window.screenX window.screenYinnerWidth outerWidth innerHeight outerHeight 获得页面可视窗口的宽度document.documentElement.clientWidthdocument.body.clientWidth 1234567891011var pageWidth = window.innerWidth,pageHeight = window.innerHeight;if (typeof pageWidth != &quot;number&quot;)&#123;if (document.compatMode == &quot;CSS1Compat&quot;)&#123;//标准模式pageWidth = document.documentElement.clientWidth;pageHeight = document.documentElement.clientHeight;&#125; else &#123;//混杂模式pageWidth = document.body.clientWidth;pageHeight = document.body.clientHeight;&#125;&#125; 检测浏览器新开窗口是否被阻止：123456789101112var blocked = false;try &#123;var wroxWin = window.open(&quot;http://www.baidu.com&quot;, &quot;_blank&quot;);if (wroxWin == null)&#123;blocked = true;&#125;&#125; catch (ex)&#123;blocked = true;&#125;if (blocked)&#123;alert(&quot;The popup was blocked!&quot;);&#125; setTimeout:123456//设置超时调用var timeoutId = setTimeout(function() &#123;alert(&quot;Hello world!&quot;);&#125;, 1000);//注意：把它取消clearTimeout(timeoutId); JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个参数告诉JavaScript再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。 超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined。 一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，最好不要使用间歇调用。 1234567891011121314// 在这个例子中，变量num每半秒钟递增一次，当递增到最大值时就会取消先前设定的间歇调用。这//个模式也可以使用超时调用来实现。var num = 0;var max = 10;function incrementNumber() &#123;num++;//如果执行次数未达到max设定的值，则设置另一次超时调用if (num &lt; max) &#123;setTimeout(incrementNumber, 500);&#125; else &#123;alert(&quot;Done&quot;);&#125;&#125;setTimeout(incrementNumber, 500); viewpointlocation: hash host hostname href parthname port protocal search这些值随便改变一个都会在浏览器历史记录里重新生成一条记录 可以通过后退或者前进访问到要防止这种行为，可以通过1234567891011121314151617181920212223242526272829## BOM 浏览器对象模型 以Windows对象为依托，表示浏览器窗口以及页面的可见区域&gt;浏览器对象模型（BOM）以window对象为依托，表示浏览器窗口以及页面可见区域。同时，window对象还是ECMAScript中的Global对象，因而所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下。本章讨论了下列BOM的组成部分。 在使用框架时，每个框架都有自己的window对象以及所有原生构造函数及其他函数的副本。每个框架都保存在frames集合中，可以通过位置或通过名称来访问。 有一些窗口指针，可以用来引用其他框架，包括父框架。 top对象始终指向最外围的框架，也就是整个浏览器窗口。 parent对象表示包含当前框架的框架，而self对象则回指window。 使用location对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性地修改浏览器的URL。 调用replace()方法可以导航到一个新URL，同时该URL会替换浏览器历史记录中当前显示的页面。 navigator对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏览器；不过，也有一些公共的属性（如userAgent）存在于所有浏览器中。BOM中还有两个对象：screen和history，但它们的功能有限。screen对象中保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。history 对象为访问浏览器的历史记录开了一个小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。## DOMgetElementByIdgetElementByTagNamegetAttribute setAttribute removeAttributequerySelectorquerySelectorAll var $div=document.getElementById(‘mydiv’);console.log($div.getAttribute(‘data-id’)); 1234## 动态引入JS或者CSS** 引入脚本 *** 引入外部文件 function loadScript(url){var script = document.createElement(“script”);script.type = “text/javascript”;script.src = url;document.body.appendChild(script);}//然后，就可以通过调用这个函数来加载外部的JavaScript文件了：loadScript(“client.js”);12* 行内方式 function loadScriptString(code){var script = document.createElement(“script”);script.type = “text/javascript”;try {script.appendChild(document.createTextNode(code));} catch (ex){script.text = code;}document.body.appendChild(script);}//下面是调用这个函数的示例：loadScriptString(“function sayHi(){alert(‘hi’);}”);123** 引入CSS *** 引入外部文件 function loadStyles(url){var link = document.createElement(“link”);link.rel = “stylesheet”;link.type = “text/css”;link.href = url;var head = document.getElementsByTagName(“head”)[0];head.appendChild(link);}//调用loadStyles()函数的代码如下所示：loadStyles(“styles.css”);12* 行内方式 function loadStyleString(css){var style = document.createElement(“style”);style.type = “text/css”;try{style.appendChild(document.createTextNode(css));} catch (ex){style.styleSheet.cssText = css;}var head = document.getElementsByTagName(“head”)[0];head.appendChild(style);} //调用这个函数的示例如下：loadStyleString(“body{background-color:red}”);12345678910111213## HTMLDocument的变化&gt; * document.readyState loading/complete&gt; * 兼容模式 document.compatMode CSS1Compat(标准模式) BackCompat(混杂模式)&gt;var head = document.head || document.getElementsByTagName(&quot;head&quot;)[0];&gt;$(&apos;#p5&apos;)[0].scrollIntoView()&gt;clientWidth=元素内容宽度+内边距宽度 clientHeight=元素内容高度+内边距高度 function getViewport(){if (document.compatMode == “BackCompat”){return {width: document.body.clientWidth,height: document.body.clientHeight};} else {return {width: document.documentElement.clientWidth,height: document.documentElement.clientHeight};}}12 var docHeight = Math.max(document.documentElement.scrollHeight,document.documentElement.clientHeight);var docWidth = Math.max(document.documentElement.scrollWidth,document.documentElement.clientWidth);``` scrollLeft scrollTop scrollHeight scrollWidth getBoundingClientRect()","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/Javascript/"},{"name":"读书","slug":"读书","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/读书/"},{"name":"基础篇","slug":"基础篇","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/基础篇/"}]},{"title":"微信硬件JS-Api开发不完全指南","slug":"微信硬件JS-Api开发不完全指南","date":"2017-02-06T02:11:59.000Z","updated":"2017-04-16T16:29:25.000Z","comments":true,"path":"2017/02/06/微信硬件JS-Api开发不完全指南/","link":"","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/2017/02/06/微信硬件JS-Api开发不完全指南/","excerpt":"1.引入JS库 1&lt;script type=&apos;text/javascript&apos; src=&apos;//res.wx.qq.com/open/js/jweixin-1.0.0.js&apos;&gt;&lt;/script&gt; 2.为页面注入配置信息","text":"1.引入JS库 1&lt;script type=&apos;text/javascript&apos; src=&apos;//res.wx.qq.com/open/js/jweixin-1.0.0.js&apos;&gt;&lt;/script&gt; 2.为页面注入配置信息123456789wx.config(&#123; beta: true, // 开启内测接口调用，注入wx.invoke方法,非常重要!!必须有这个 debug: true,//开启调试接口，alert运行结果 appId: &apos;&apos;,//必填，公众号的唯一标识, timestamp: &apos;&apos;,//必填，生成签名的时间戳 nonceStr: &apos;&apos;,//必填，生成签名的随机串 signature: &apos;&apos;,//必填，签名 jsApiList: []//要调用的js函数，必须把函数名字写入数组&#125;); 这里我的jsApiList为12345678910111213141516jsApiList: [ &apos;openWXDeviceLib&apos;,//初始化设备库（只支持蓝牙设备） &apos;closeWXDeviceLib&apos;,//关闭设备库（只支持蓝牙设备） &apos;getWXDeviceInfos&apos;,//获取设备信息（获取当前用户已绑定的蓝牙设备列表） &apos;sendDataToWXDevice&apos;,//发送数据给设备 &apos;startScanWXDevice&apos;,//扫描设备（获取周围所有的设备列表，无论绑定还是未被绑定的设备都会扫描到） &apos;stopScanWXDevice&apos;,//停止扫描设备 &apos;connectWXDevice&apos;,//连接设备 &apos;disconnectWXDevice&apos;,//断开设备连接 &apos;getWXDeviceTicket&apos;,//获取操作凭证 &apos;onWXDeviceBindStateChange&apos;,//微信客户端设备绑定状态被改变时触发此事件 &apos;onWXDeviceStateChange&apos;,//监听连接状态，可以监听连接中、连接上、连接断开 &apos;onReceiveDataFromWXDevice&apos;,//接收到来自设备的数据时触发 &apos;onScanWXDeviceResult&apos;,//扫描到某个设备时触发 &apos;onWXDeviceBluetoothStateChange&apos;,//手机蓝牙打开或关闭时触发 ] 如果想要测一下微信版本是不是支持这几个api，可以这样写：1234567 wx.checkJsApi(&#123; jsApiList: [&apos;openWXDeviceLib&apos;, &apos;onScanWXDevicesResult&apos;, &apos;getWXDeviceInfos&apos;], // 需要检测的JS接口列表，所有JS接口列表见附录2, success: function (res) &#123; console.log(res); &#125;&#125;); 3.初始化设备库函数 通过ready接口处理成功验证123456wx.ready(function () &#123; wx.invoke(&apos;openWXDeviceLib&apos;, &#123;connType: &apos;blue&apos;&#125;, function (res) &#123; console.debug(&apos;openWXDeviceLib重新打开设备库==&gt;&apos;); console.log(res); &#125;);&#125;) 坑：重新扫描设备根本什么都扫不出来，即使是刷新页面也不顶用 解决方法：每次扫描前，先调用closeWXDeviceLib关闭设备库，再调用openWXDeviceLib打开设备库。这样就相当于重新初始化了一遍设备库，你现在再重新扫描，就可以扫描到设备了。 代码：1234567891011121314wx.invoke(&quot;stopScanWXDevice&quot;, &#123;&#125;, function (res) &#123; console.debug(&apos;stopScanWXDevice&apos;); console.log(res); &#125;);wx.invoke(&quot;closeWXDeviceLib&quot;, &#123;&#125;, function (res) &#123; console.debug(&apos;closeWXDeviceLib关闭设备库==&gt;&apos;); console.log(res);&#125;);wx.invoke(&apos;openWXDeviceLib&apos;, &#123;connType: &apos;blue&apos;&#125;, function (res) &#123; console.debug(&apos;openWXDeviceLib重新打开设备库==&gt;&apos;); console.log(res);&#125;); 4.监听设备返回的信息1234wx.on(&apos;onReceiveDataFromWXDevice&apos;, function (res) &#123; console.warn(&apos;onReceiveDataFromWXDevice=&gt;&apos;); console.log(JSON.stringify(res));&#125;); 5.发送消息到设备 收发数据前需进行 base64 的编解码。这里，我用到一个库：1&lt;script type=&apos;text/javascript&apos; src=&apos;base64.js&apos;&gt;&lt;/script&gt; 出处：https://github.com/dankogai/js-base64/blob/master/base64.js 12345678910var data=&#123;&quot;deviceId&quot;:deviceId,&quot;base64Data&quot;: Base64.encode(&apos;你要发送的数据&apos;)&#125;;console.log(data);wx.invoke(&apos;sendDataToWXDevice&apos;,data , function(res)&#123; //回调 console.info(&apos;发消息到设备sendMsg&apos;); console.log(data); console.log(res); $(&apos;#dataFromDevice&apos;).append(&apos;发送消息的结果：&apos;+JSON.stringify(res)); alert(&apos;已发送 请查看控制板&apos;);&#125;); 说明： 1.需要在微信对应设备号内才能使用对应的api。 2.必须要在设备号设置的安全域名下才能正常使用api 3.本篇内所有的console.log 等输出到控制台 都是用的vconsole调试工具实现。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/Javascript/"},{"name":"html5","slug":"html5","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/html5/"},{"name":"PHP","slug":"PHP","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/PHP/"},{"name":"服务号","slug":"服务号","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/服务号/"}]},{"title":"关于PHP导出CSV文件的实现过程以及一些经常遇到的问题研究","slug":"关于PHP导出CSV文件的实现过程以及一些经常遇到的问题研究","date":"2016-12-09T18:11:59.000Z","updated":"2017-04-16T16:28:18.000Z","comments":true,"path":"2016/12/10/关于PHP导出CSV文件的实现过程以及一些经常遇到的问题研究/","link":"","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/2016/12/10/关于PHP导出CSV文件的实现过程以及一些经常遇到的问题研究/","excerpt":"写在前面：预告：前两天做了很多关于导入导出CSV、照片的蛋疼的需求，准备上一篇大文章~正在总结中……如果有空，下周六应该可以出~ 导出功能在管理后台算是比较常见的了。在实现导出表格类信息的功能时，可以选择两种实现方式： 导出为excel 导出为csv文件格式 用csv方式导出，则可以像导出txt一样，以文本流的方式进行流式处理，不但能导出海量信息，而且流式处理占用内存极低，服务器对浏览器的响应也是非常迅速的。理论上是不限量的。具体能导出多少条，是由服务器的响应时间、PHP的运行时间和内存等限制决定。但是如果用excel来打开csv，超过65536行的数据都会看不见，这是excel程序的问题。本次导出数据量很大。所以选择csv。","text":"写在前面：预告：前两天做了很多关于导入导出CSV、照片的蛋疼的需求，准备上一篇大文章~正在总结中……如果有空，下周六应该可以出~ 导出功能在管理后台算是比较常见的了。在实现导出表格类信息的功能时，可以选择两种实现方式： 导出为excel 导出为csv文件格式 用csv方式导出，则可以像导出txt一样，以文本流的方式进行流式处理，不但能导出海量信息，而且流式处理占用内存极低，服务器对浏览器的响应也是非常迅速的。理论上是不限量的。具体能导出多少条，是由服务器的响应时间、PHP的运行时间和内存等限制决定。但是如果用excel来打开csv，超过65536行的数据都会看不见，这是excel程序的问题。本次导出数据量很大。所以选择csv。总体实现思路为：先把需要导出的数据存到数组里，然后写入到文件。话不多说，还是直接上代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function export()&#123; $data=array( array( &apos;nId&apos; =&gt; &apos;90&apos;, &apos;nick&apos; =&gt; &apos;piapia&apos;, ), array( &apos;nId&apos; =&gt; &apos;91&apos;, &apos;nick&apos; =&gt; &apos;monkey&apos;, ) ); $head = array( &apos;nId&apos; =&gt; &apos;id&apos;, &apos;nick&apos; =&gt; &apos;昵称&apos;, ); $name = &quot;filetoexport&quot; . date(&apos;YmdHis&apos;, time()); $this-&gt;writeCsvToBrowser($name, $head, $data);&#125;function writeCsvToBrowser($filename,$headLine,$data,$lostData=array()) &#123; $out = implode(&apos;,&apos;, $headLine); $out = iconv(&apos;UTF-8&apos;, &apos;GBK//IGNORE&apos;,$out); foreach ($data as $v) &#123; $line = array(); foreach (array_keys($headLine) as $objAttr) &#123; if (is_object($v) &amp;&amp; isset($v-&gt;$objAttr)) &#123; $cellValue = $v-&gt;$objAttr; &#125;elseif(is_array($v) &amp;&amp; isset($v[$objAttr])) &#123; $cellValue = $v[$objAttr]; &#125;else &#123; $cellValue = $lostData[$objAttr]; &#125; $line[] = $cellValue; &#125; $line = array_map(&apos;csvFormate&apos;,$line); $out .= &quot;\\n&quot;; $lineStr= implode(&apos;,&apos;, $line); //iconv转换编码对字符串有长度限制，如果太长就会被截断。 $lineStr= @iconv(&apos;UTF-8&apos;, &apos;GBK//IGNORE&apos;, $lineStr); $out .= $lineStr; &#125; header(&quot;Cache-Control: must-revalidate, post-check=0, pre-check=0&quot;); header(&quot;Content-Length: &quot; . strlen($out)); header(&quot;Content-type: text/x-csv&quot;); header(&quot;Content-Disposition:filename=$filename.csv&quot;); echo $out;&#125;function csvFormate($str) &#123; if (&apos;&apos;===$str) &#123; return &apos;&apos;; &#125; $find = FALSE; foreach (array(&apos;,&apos;,&apos;&quot;&apos;,&quot;\\n&quot;,&quot;\\t&quot;) as $v)&#123; if (FALSE===strpos($str, $v)) &#123; $find = true; break; &#125; &#125; if (!$find) &#123; return $str; &#125; $str = str_replace(&apos;&quot;&apos;, &apos;&quot;&quot;&apos;, $str); return sprintf(&apos;&quot;%s&quot;&apos;,$str);&#125; 在实现这个功能时，有一些问题需要大家注意一下。1.精度丢失问题：问题描述：导出后，发现有一个字段总是跟取得不一样，Id为1918553121332457在导出后变成1918553121332450，也就是说最后一位 总是变成了0。原因：Excel数值显示精度为15位造成精度丢失。解决思路：强制转化成字符串1$strId.&quot;\\t&quot; 或者1$strId.&quot;\\n&quot; 需要注意的是，这样加是没有用的：1$strId.&quot; &quot; 2.PHP运行时间的限制，导致程序被强制中断。在不能随便改变php.ini文件里PHP运行的时间限制下，可以这样设置来增加运行时间：1set_time_limit(60*5); 3.默认内存设置太小，导致文件写入失败：可以尝试这样解决1ini_set(&apos;memory_limit&apos;,&apos;1024M&apos;); 4.奇淫技巧如果不想文件在读取或者写入的时候，因为用户的误操作被中断。可以通过如下参数实现：1ignore_user_abort(true);","categories":[],"tags":[{"name":"php","slug":"php","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/php/"},{"name":"csv","slug":"csv","permalink":"https://github.com/halilolocjya/halilolocjya.github.io.git/tags/csv/"}]}]}